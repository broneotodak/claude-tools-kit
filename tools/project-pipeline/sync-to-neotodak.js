#!/usr/bin/env node

const { createClient } = require('@supabase/supabase-js');
const fs = require('fs').promises;
const path = require('path');
require('dotenv').config();

// Initialize Supabase
const supabase = createClient(
    process.env.SUPABASE_URL || 'https://uzamamymfzhelvkwpvgt.supabase.co',
    process.env.SUPABASE_SERVICE_KEY || process.env.SUPABASE_ANON_KEY
);

// Map our categories to neotodak.com format
const categoryMap = {
    'ai': 'ai',
    'automation': 'automation',
    'saas': 'saas',
    'tool': 'tool',
    'integration': 'integration',
    'research': 'research',
    'game': 'saas'
};

// Map our status to neotodak.com format
const statusMap = {
    'idea': 'development',
    'planning': 'development',
    'development': 'development',
    'beta': 'beta',
    'active': 'live',
    'maintenance': 'live',
    'archived': 'archived'
};

async function fetchProjects() {
    const { data, error } = await supabase
        .from('public_projects')
        .select('*')
        .order('status', { ascending: true });

    if (error) throw error;
    return data || [];
}

function transformToNeotodakFormat(project) {
    return {
        id: project.project_id,
        title: project.name,
        description: project.description || 'An innovative project powered by AI',
        category: categoryMap[project.category] || 'tool',
        status: statusMap[project.status] || 'development',
        complexity: project.complexity || 3,
        techStack: project.tech_stack || [],
        links: {
            live: project.links?.live || project.links?.url,
            github: project.links?.github,
            docs: project.links?.docs
        },
        metrics: project.metrics || {},
        image: project.icon || '/images/projects/default.png',
        highlights: project.highlights || [],
        challenges: project.challenges || [],
        outcomes: project.outcomes || []
    };
}

async function generateProjectsData() {
    console.log('üîÑ Fetching projects from database...');
    const projects = await fetchProjects();
    
    console.log(`üìä Found ${projects.length} projects`);
    
    // Transform to neotodak format
    const transformedProjects = projects.map(transformToNeotodakFormat);
    
    // Generate TypeScript file content
    const content = `// Auto-generated by project-pipeline
// Last updated: ${new Date().toISOString()}

import type { Project } from '@/types/project'

export const projects: Project[] = ${JSON.stringify(transformedProjects, null, 2)}

export const projectCategories = [
  { id: 'all', label: 'All Projects', count: ${transformedProjects.length} },
  { id: 'ai', label: 'AI & ML', count: ${transformedProjects.filter(p => p.category === 'ai').length} },
  { id: 'automation', label: 'Automation', count: ${transformedProjects.filter(p => p.category === 'automation').length} },
  { id: 'saas', label: 'SaaS', count: ${transformedProjects.filter(p => p.category === 'saas').length} },
  { id: 'tool', label: 'Developer Tools', count: ${transformedProjects.filter(p => p.category === 'tool').length} },
  { id: 'integration', label: 'Integrations', count: ${transformedProjects.filter(p => p.category === 'integration').length} },
  { id: 'research', label: 'Research', count: ${transformedProjects.filter(p => p.category === 'research').length} }
]

export const projectStats = {
  total: ${transformedProjects.length},
  live: ${transformedProjects.filter(p => p.status === 'live').length},
  users: ${transformedProjects.reduce((sum, p) => sum + (p.metrics?.users || 0), 0)},
  apiCalls: ${transformedProjects.reduce((sum, p) => sum + (p.metrics?.apiCalls || 0), 0)}
}
`;

    return { content, projects: transformedProjects };
}

async function updateNeotodakRepo(content) {
    const repoPath = '/Users/broneotodak/Projects/neotodak-ai-labs';
    const filePath = path.join(repoPath, 'lib', 'projects-data.ts');
    
    try {
        // Check if repo exists
        await fs.access(repoPath);
        
        // Write the file
        await fs.writeFile(filePath, content);
        console.log(`‚úÖ Updated ${filePath}`);
        
        // Create a commit script
        const commitScript = `#!/bin/bash
cd ${repoPath}
git add lib/projects-data.ts
git commit -m "Auto-update projects from database

- Synced ${new Date().toISOString()}
- Source: Project Pipeline System

ü§ñ Generated by Claude Tools Kit"
git push origin main
`;
        
        const scriptPath = path.join(repoPath, 'auto-commit-projects.sh');
        await fs.writeFile(scriptPath, commitScript);
        await fs.chmod(scriptPath, '755');
        
        console.log('üìù Created commit script at:', scriptPath);
        console.log('Run it to push changes to GitHub');
        
    } catch (error) {
        console.error('‚ùå Could not update neotodak repo:', error.message);
        console.log('\nüí° Saving to current directory instead...');
        await fs.writeFile('./projects-data.ts', content);
        console.log('‚úÖ Saved to ./projects-data.ts');
    }
}

async function syncProjects() {
    try {
        const { content, projects } = await generateProjectsData();
        
        console.log('\nüìã Project Summary:');
        console.log(`- Active: ${projects.filter(p => p.status === 'live').length}`);
        console.log(`- Beta: ${projects.filter(p => p.status === 'beta').length}`);
        console.log(`- Development: ${projects.filter(p => p.status === 'development').length}`);
        
        await updateNeotodakRepo(content);
        
        // Also create a webhook notification
        console.log('\nüîî Creating webhook notification...');
        await createWebhook(projects.length);
        
    } catch (error) {
        console.error('‚ùå Sync failed:', error);
        process.exit(1);
    }
}

async function createWebhook(projectCount) {
    // This could trigger n8n or another automation
    const webhook = {
        event: 'projects_updated',
        timestamp: new Date().toISOString(),
        data: {
            total_projects: projectCount,
            source: 'project_pipeline',
            action: 'sync_to_neotodak'
        }
    };
    
    console.log('ü™ù Webhook data:', webhook);
    // In production, you'd send this to n8n or another service
}

// Run if called directly
if (require.main === module) {
    syncProjects()
        .then(() => {
            console.log('\n‚ú® Sync completed successfully!');
            process.exit(0);
        })
        .catch(error => {
            console.error('\n‚ùå Sync failed:', error);
            process.exit(1);
        });
}

module.exports = { syncProjects, fetchProjects };